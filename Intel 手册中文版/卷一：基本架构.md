翻译前先阅读整体规则的 [README](https://github.com/sunym1993/flash-linux0.11-talk/blob/main/Intel%20%E6%89%8B%E5%86%8C%E4%B8%AD%E6%96%87%E7%89%88/README.md) 哟~

# 目录

这里是目录，要有锚点链接。

[@翻译人：闪客sun](https://github.com/sunym1993/flash-linux0.11-talk)

本卷是讲述 Intel 64 和 IA-32 架构处理器体系结构和编程环境的一部分，其他卷分别是：

- [卷二：指令集参考](https://github.com/sunym1993/flash-linux0.11-talk/blob/main/Intel%20手册中文版/卷二：指令集参考.md)
- [卷三：系统编程指南](https://github.com/sunym1993/flash-linux0.11-talk/blob/main/Intel%20手册中文版/卷三：系统编程指南.md)
- [卷四：特殊模块寄存器（MSR）](https://github.com/sunym1993/flash-linux0.11-talk/blob/main/Intel%20手册中文版/卷四：特殊模块寄存器（MSR）.md)

卷一描述了处理器的基本架构和编程环境；卷二描述了处理器的指令集和操作码（opcode）结构；卷三描述了处理器的操作系统支持环境，主要针对操作系统和 BIOS 的设计；卷四描述了处理器的 MSR 寄存器。

## 1.1 支持的处理器型号

本手册包含了最新的 Intel 64 和 IA-32 处理器，如下：

```
- Pentium® processorsP6 family processors
- Pentium® 4 processors
- Pentium® M processors
- Intel® Xeon® processors
- Pentium® D processors
- Pentium® processor Extreme Editions
- 64-bit Intel® Xeon® processors
- Intel® Core™ Duo processor
- Intel® Core™ Solo processor
- Dual-Core Intel® Xeon® processor LV
- Intel® Core™2 Duo processor
- Intel® Core™2 Quad processor Q6000 series
- Intel® Xeon® processor 3000, 3200 series
- Intel® Xeon® processor 5000 series
- Intel® Xeon® processor 5100, 5300 series
- Intel® Core™2 Extreme processor X7000 and X6800 series
- Intel® Core™2 Extreme processor QX6000 series
- Intel® Xeon® processor 7100 series1-2Vol. 1ABOUT THIS MANUAL
- Intel® Pentium® Dual-Core processor
- Intel® Xeon® processor 7200, 7300 series
- Intel® Xeon® processor 5200, 5400, 7400 series
- Intel® Core™2 Extreme processor QX9000 and X9000 series
- Intel® Core™2 Quad processor Q9000 series
- Intel® Core™2 Duo processor E8000, T9000 series
- Intel® Atom™ processor family
- Intel® Atom™ processors 200, 300, D400, D500, D2000, N200, N400, N2000, E2000, Z500, Z600, Z2000, C1000 series are built from 45 nm and 32 nm processes
- Intel® Core™ i7 processor
- Intel® Core™ i5 processor
- Intel® Xeon® processor E7-8800/4800/2800 product families 
- Intel® Core™ i7-3930K processor
- 2nd generation Intel® Core™ i7-2xxx, Intel® Core™ i5-2xxx, Intel® Core™ i3-2xxx processor series
- Intel® Xeon® processor E3-1200 product family
- Intel® Xeon® processor E5-2400/1400 product family
- Intel® Xeon® processor E5-4600/2600/1600 product family
- 3rd generation Intel® Core™ processors
- Intel® Xeon® processor E3-1200 v2 product family
- Intel® Xeon® processor E5-2400/1400 v2 product families
- Intel® Xeon® processor E5-4600/2600/1600 v2 product families
- Intel® Xeon® processor E7-8800/4800/2800 v2 product families
- 4th generation Intel® Core™ processors
- The Intel® Core™ M processor family 
- Intel® Core™ i7-59xx Processor Extreme Edition
- Intel® Core™ i7-49xx Processor Extreme Edition
- Intel® Xeon® processor E3-1200 v3 product family
- Intel® Xeon® processor E5-2600/1600 v3 product families
- 5th generation Intel® Core™ processors
- Intel® Xeon® processor D-1500 product family
- Intel® Xeon® processor E5 v4 family
- Intel® Atom™ processor X7-Z8000 and X5-Z8000 series
- Intel® Atom™ processor Z3400 series
- Intel® Atom™ processor Z3500 series
- 6th generation Intel® Core™ processors
- Intel® Xeon® processor E3-1500m v5 product family
- 7th generation Intel® Core™ processors
- Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series 
- Intel® Xeon® Processor Scalable Family 
- 8th generation Intel® Core™ processors
- Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series
- Intel® Xeon® E processors
- 9th generation Intel® Core™ processors
- 2nd generation Intel® Xeon® Processor Scalable Family Vol. 11-3ABOUT THIS MANUAL
- 10th generation Intel® Core™ processors
- 11th generation Intel® Core™ processors
- 3rd generation Intel® Xeon® Processor Scalable Family
```
## 1.2 概览

@翻译人：xushunke

此手册的概述内容如下:  
__第一章 - 关于此手册。__ 给出全五册《Intel® 64 和 IA-32 架构软件开发者手册》的简要描述。同时介绍了在这几卷中会出现的标记习惯，关联的 Intel® 手册以及来自开发者们和硬件设计者们的关联文章。  
__第二章 - Intel® 64 和 IA-32 架构。__ 介绍 Intel 64 和 IA-32 架构以及基于此架构的 Intel 处理器家族。同时列出这些处理器的公共特性以及给出 Intel 64 和 IA-32 架构的简要历史介绍。    
__第三章 - 基本执行环境。__ 介绍内存组织模型以及介绍被应用所使用的寄存器集合。  
__第四章 - 数据类型。__ 描述被处理器所识别的数据模型和关联模型；提供关于实数与浮点格式和浮点异常的概述。  
__第五章 - 指令集汇总。__ 列出所有 Intel 64 和 IA-32 指令，根据技术类别分组。  
__第六章 - 过程调用，中断与异常。__ 描述过程调用栈的原理以及进行过程调用,产生中断和抛出异常的机制。  
__第七章 - 使用通用指令编程。__ 描述基本的加载和写入，程序控制，算数以及作用于基础数据类型的字符串指令和面向通用目的的段寄存器；同时描述了在保护模式可调用的系统指令。  
__第八章 - 使用 x87 FPU 编程。__ 描述了 x87 浮点单元（FPU），包括其中的浮点寄存器和数据类型；列出所有浮点指令集以及描述处理器产生浮点异常的条件。  
__第九章 - 使用 Intel® MMX 技术编程。__ 描述 Intel MMX 技术，其中包含 MMX 寄存器和数据类型；同时列出所有的 MMX 指令集。    
__第十章 - 使用 Intel® 流式 SIMD 扩展（Intel® SSR）编程。__ 描述 SSE 扩展，其中包含 XXM 寄存器，MXCSR 寄存器以及编码的单精度浮点数据类型；列出所有 SSE 指令集以及给出书写访问 SSE 扩展的代码的准则。    
__第十一章 - 使用 Intel® 流式 SIMD 二代扩展（Intel® SSR2）编程。__ 描述 SSE2 扩展，其中包含 XXM 寄存器和编码的双精度浮点数据类型；列出所有的 SSE2 指令集以及给出书写访问 SSE2 扩展的代码的准则。 本章同时也描述了 SSE 和 SSE2 指令可能产生的 SIMD 浮点异常。也提供了在操作系统中和应用代码中使用 SSE 和 SSE2 扩展的通常准则。   
__第十二章 - 使用 Intel® 流式 SIMD 三代扩展（Intel® SSR3），补充 Intel® 流式 SIMD 三代扩展（Intel® SSSR3），Intel® 流式 SIMD 四代扩展（Intel® SSR4）和 Intel® AES 新指令集（Intel® AES-NI）编程。__ 列出所有 SSE3，补充 SSE3，SSE4，AESNI 指令集以及书写访问这些扩展的代码的准则。         
__第十三章 - 使用 XSAVE 特性集来管理状态。__ 描述 XSAVE 特性集指令，介绍了软件是如何开启 XSAVE 特性集以及开启 XSAVE 后的会带来的特性。  
__第十四章 - 使用 AVX，FMA 和 AVX2 编程。__ 介绍 Intel® AVX 指令集，FMA 和 AVX2 扩展以及给出书写访问这些扩展的的代码的准则。  
__第十五章 - 使用 Intel® AVX-512 编程。__ 介绍 Intel® AVX-512 指令集扩展和给出书写访问这些扩展的代码的准则。  
__第十六章 - 使用 Intel 事务同步扩展编程。__ 描述通过销锁技术来提升多线程软件竞争线程锁的性能的指令集扩展。  
__第十七章 - Intel® 内存保护扩展。__ 描述 Intel® 内存保护扩展和给出书写访问这些扩展的代码的准则。  
__第十八章 - 控制流执行技术。__ 描述控制流执行技术（CET）以及给出访问这些扩展的的代码的准则。  
__第十九章 - 输入/输出。__ 描述处理接的 I/O 机制，其中包含 I/O 端口地址，I/O 指令和 I/O 保护机制。    
__第二十章 - 处理器识别与特性判别。__ 描述如何判别 CPU 类型和识别处理器中可用的特性的方法。  
__附录A - EFLAGS 交叉引用。__ 汇总描述了 IA-32 指令是如何影响 EFLAGS 里面的标记的。  
__附录B - EFLAGS 条件码。__ 汇总描述了 _条件跳转（condition jump）_ ，_转移（move）_ 以及 _'byte set on condition code'_ 指令是如何使用 EFLAGS 寄存器中的条件码标记（OF，CF，ZF，SF和PF）的。  
__附录C - 浮点异常汇总。__ 汇总描述了异常是如何被 x87 浮点单元的浮点指令和 SSE/SSE2/SSE3 浮点指令所抛出的。  
__附录D - 书写 SIMD 浮点异常句柄的准则。__ 给出了书写由 SSE/SSE2/SSE3 浮点指令所产生的异常处理句柄的代码的准则。  

## 1.3 标记习惯  

@翻译人：xushunke

此手册中为数据结构格式，指令的符号，十六进制与二进制的数字做了特定标记。这些标记将在下方说明。  

### 1.3.1 位和字节序

@翻译人：hdszylcd19

在内存中的数据结构图示中，较小的内存地址显示在图的底部；从下往上增加到顶部。Bit positions 从右到左编号。该 Bit 位的值等于 2 的 positions 次方（译者注：原文的表述有点儿晦涩，不好理解。其中，position 从 0 开始，说人话就是，二进制位上 1 所表示的数值，从右往左依次为：2 的 0 次方、2 的 1 次方...）。

Intel 和 IA-32 处理器都是采用“little endian（小端）”方式存储数据；这意味着 word 的字节序是从最低有效字节开始编号（译者注：关于“大端”和“小端”问题，请查看 [大端（Big-Endian）和小端（Little-Endian）](https://juejin.cn/post/6930889701507203085/#comment)）。请看图1-1。

### 1.3.2 保留位与软件兼容性

@翻译人：三分月色

在许多寄存器和内存布局描述中会有一些保留位。这些被标记为保留位的比特，是为了与未来的处理器兼容，尽管未来是未知的，软件仍将这些位视为对未来有重要影响。保留位的行为应该被认为是未定义(undefined)且不可预测的。

在处理保留位时，软件应遵循以下准则：

* 当测试含保留位的寄存器的值时，不依赖保留位的状态。应在测试之前屏蔽掉保留位。
* 存储到内存或寄存器时，不依赖于保留位的状态。
* 不依赖保留位保持信息(retain information)的能力。
* 加载寄存器时，始终使用文档中指示的值加载保留位(如果有的话)，或者使用先前从同一寄存器读取的值重新加载保留位。

<center>注意</center>

避免任何软件依赖于 Inter 64和 IA-32 寄存器中的保留位状态。依赖寄存器的保留位，软件会依赖于处理器处理这些位的一种不确定的方式。依赖保留位的程序增加了与未来处理器不兼容的风险。

#### 1.3.2.1 指令操作符（Instruction Operands）

（译者注：这里指令名称与操作数统称为 operands）

当指令用符号表示时，会使用 IA-32 汇编语言的一个子集。在这个子集中，指令具有以下格式：

标签:助记词（参数1）,参数2, 参数3

其中：

* 标签是一个唯一标识符，其后跟着一个冒号。
* 助记词是一类具有相同功能的指令操作码的保留名称（译者注：即指令名称）。
* 参数1、参数2、参数3 是可选的。根据操作码的不同，可能有 0～3 个参数。当他们出现的时候，采用数据项的字面意思或者标识符的形式。标识符要么是寄存器的保留名称，要么是假定赋值给程序中另一部分声明的数据项(可能在示例中没有显示)。
* 当算术或逻辑指令中有两个操作数时，右操作数是源，左操作数是目的。

例如：

​	LOADREG: MOV EAX, SUBTOTAL

在这个例子中，LOADREG 是标签，MOV 是操作码的助记标识符，EAX 是目标操作数，SUBTOTAL 是源操作数。有些汇编语言可能会将源和目标操作数放在相反的顺序。

### 1.3.3 16 进制与 2 进制数字

16 进制数字以一串 16 进制的数字（译者注：含字母）后跟字母 H 表示，（例如，0F82EH）。十六进制数字可以是0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F中的一个字符。

2 进制数字由 1 和 0 组成的字符串表示，有时后面跟着字符 B(例如，1010B)。只有在数字类型可能引起混淆的情况下才使用字符 B。

### 1.3.4 段寻址（Segmented Addressing）

处理器使用字节寻址。这意味着内存是作为一个字节序列被组织和访问的。无论访问一个或多个字节，字节地址都用于定位单个字节或多个字节内存地址。可寻址的内存范围称为**地址空间**（address space）。

处理器也支持段寻址。这是一种寻址方式，程序可以有许多独立的地址空间，称为**段**（segments）。例如，一个程序可以将它的代码(指令)和堆栈保存在单独的段中。代码地址总是指向代码空间，堆栈地址总是指向堆栈空间。下面的表示法用于指定段内的字节地址：

​	段寄存器:字节地址

例如，下面的段地址标识 DS 寄存器所指向的段中地址 FF79H 处的字节：

​	DS:FF79H

下面的段地址标识代码段中的指令地址。CS 寄存器指向代码段，EIP 寄存器包含指令的地址。

​	CS:EIP

### 1.3.5 用于 CPUID、CR 和 MSR 值的新语法

通过使用 CPUID 指令、检查控制寄存器位和读取特定于模型的寄存器来获取特征标志、状态和系统信息。我们正在研究一种新的语法来表示这些信息。见图1 - 2。

### 1.3.6 异常

异常通常是指令出错时发生的事件。例如，尝试除以 0 会产生异常。然而，在其他条件下也会出现一些例外情况，例如断点（breakpoints）。某些类型的异常会提供错误码。错误码提供关于错误的附加信息。下面是用来显示异常和错误码的符号示例：

\#PF(错误码)

一个错误码定义了一种错误类型，上例是一个页面错误异常（page-fault exception）。在某些情况下，可能无法给到一个准确的错误码。在这种情况下，错误码为零，如下图所示为通用保护异常：

\#GP(0)

# 第二章 Intel 64 and IA-32 Architectures

## 2.1 INTEL® 64 与 IA-32 架构的简要历史

以下章节提供了从 IA-32 到 Intel 64 架构的主要技术演进的摘要：从 Intel 8086 处理器开始到最新的 Intel®Core®2Duo，Core 2 Quad 和 Intel Xeon 处理器 5300 和 7300 系列。1978 年以前发布的处理器创建的对象代码仍然在 Inter 64 和 IA-32 架构系列中的最新处理器上运行着。

### 2.1.1 16 位处理器与段（1978）

在 IA-32 体系结构家族之前，有 16 位处理器 8086 和 8088。8086  有 16 位寄存器和 16 位外部数据总线，20 位寻址提供 1-MByte 地址空间。8088 与 8086 相似，但它有一个 8 位的外部数据总线。

8086/8088 向 IA-32 架构引入了段（segmentation）。通过分段， 16 位段寄存器可以指向高达 64 KB 的内存段。同时使用四个段寄存器，8086/8088 处理器能够不在段之间切换的情况下寻址达 256 KB。使用段寄存器和额外的 16 位指针可以形成的 20 位地址提供 1 MB 的总寻址范围。

### 2.1.2  Intel® 286 处理器（1982）

Intel 286 处理器向 IA-32 架构中引入了保护模式。保护模式使用段寄存器的内容作为选择器（selector）或指针指向描述符表（descriptor table）。描述符（Descriptor）提供 24 位基址，物理内存可达 16 MB，支持基于段交换的虚拟内存管理，以及一些保护机制。这些机制包括：

* 段限制检查
* 只读和只执行段选项
* 四种特权级

### 2.1.3 Intel 386 处理器（1985）

Intel 386 处理器是 IA-32 体系结构家族中的第一个 32 位处理器。它引入了 32 位寄存器用于保存操作数和寻址。每个 32 位 Intel 386 寄存器的低地址保留了早期 16 位寄存器的内容，允许向后兼容。 386 处理器还提供虚拟化 8086 模式，使得在执行 8086/8088 处理器创建的程序时效率更高。

此外，Intel 386 处理器支持以下功能:

* 32 位地址总线，支持多达 4 GB 物理内存
* 段内存模型和一个平面（flat）内存模型
* 分页，使用固定的 4 KB 页面大小为虚拟内存管理提供了一种方法
* 支持并行级

### 2.1.4 Intel 486 处理器（1989）

Intel 486 处理器通过将 Intel 386 处理器的指令解码（decode）和执行（execution）扩展到五个流水线步骤，增加了并行执行能力。在不同的执行阶段，每个阶段与其他阶段并行操作，最多可并行执行 5 条指令。

此外，处理器还增加了：

* 一个 8 KB 芯片一级缓存，增加了在每个时钟上执行指令的数量
* 集成 x87 FPU
* 节能和系统管理能力

### 2.1.5 The Intel® Pentium® 处理器 (1993)

Intel Pentium processor 的引入增加了第二个执行管道（execution pipeline），以实现超量性能(两个管道，称为 u 和 v，一起可以在每个时钟上执行两条指令)。芯片上的一级缓存增加了一倍，其中 8 KB 用于代码，另外 8 KB 用于数据。除了 Intel 486 处理器使用的透写缓存（write-through cache）外，数据缓存使用 MESI 协议来支持更有效的回写缓存（write-back cache）。为了提高循环结构的性能，增加了带有芯片上分支表的分支预测。

此外，处理器还增加了：

* 扩展使虚拟 8086 模式更高效，并允许 4MB 和 4KB 页面大小
* 128 和 256 位的内部数据路径提速到内部数据传输
* 突破性的外部数据总线增加到 64 位
* 支持多处理器系统的 APIC
* 双处理器模式，支持无胶（glueless）双处理器系统

奔腾系列后续引入了 Intel MMX 技术(带 MMX 技术的奔腾处理器)。INTEL MMX 技术使用单指令，多数据（SIMD）执行模型来并行执行 64 位寄存器中的包装（packed）整数数据。

参见 2.2.7 节， “SIMD 指令”。（Todo link）

### 2.1.6 - 2.1.22
[@翻译人：zhangkai803](https://github.com/zhangkai803)

# 第三章 Basic Execution Environment
## 3.1 操作模式

IA-32 架构支持三种基本的运行模式:保护模式、实地址模式和系统管理模式。操作模式决定了哪些指令和架构特性是可用的。

* **保护模式**（Protected mode）--该模式是处理器的本机状态（native state）。保护模式是指能够在受保护的多任务环境中直接执行实地址模式 8086 软件。这个特性被称为**虚拟-8086 模式**，尽管它实际上不是处理器模式。虚拟-8086 模式实际上是保护模式的一个属性，可以被任何任务开启。

* **实地址模式**（Real-address mode）-- 该模式实现了 Intel 8086 处理器的编程环境，具有扩展功能(例如切换到保护模式或系统管理模式的能力)。处理器在通电或复位后被置于实地址模式。

* **系统管理模式** (System management mode，SMM)--该模式为操作系统或执行程序提供透明的机制，实现平台相关特有的功能，如电源管理、系统安全等。当外部 SMM 中断引脚(SMI#--SMM interrupt)被激活或从高级可编程中断控制器(APIC)接收到 SMI 时，处理器进入 SMM。

在 SMM 中，当保存当前运行的程序或任务的基本上下文时，处理器切换到一个单独的地址空间。然后可以透明地执行特定于 SMM 的代码。当从 SMM 返回时，处理器被放置回系统管理中断之前的状态。SMM 是在 Intel386 SL 和 Intel486 SL 处理器中引入的，并成为奔腾处理器家族的标准 IA-32 特性。

### 3.1.1 Intel® 64 架构

Intel 64 架构增加了 IA-32E 模式。IA-32E 模式有两个子模式。他们是：

* 兼容模式（IA-32E 模式的子模式） - 兼容模式允许大多数传统的 16 位和 32 位应用程序在无需重新编译情况下运行在 64 位操作系统。兼容性子模式在 IA-32 架构中简称为兼容模式。兼容模式的执行环境与 3.2 节描述相同。兼容模式还支持 64 位和保护模式支持的所有特权级。以虚拟 8086 模式或使用硬件任务管理的遗留应用程序不能在此模式下工作。

  兼容模式是操作系统在代码段的基础上启用的。这意味着单个 64 位操作系统可以支持以 64 位的应用程序以 64 位模式运行，并支持以兼容模式运行的传统的 32 位应用程序（未重新编译为 64 位）。

  兼容性模式类似于 32 位保护模式。应用程序只访问线性地址空间的前 4 G。兼容模式使用 16 位和 32 位地址和操作数大小。与保护模式一样，这种模式允许应用程序使用 PAE(Physical Address Extensions)访问大于 4 G 的物理内存。

* 64 位模式（IA 32e 模式的子模式）- 这种模式使 64 位操作系统能够运行访问 64 位地址空间的应用。64 位子模式在 IA-32 架构中简称为 64 位模式。

  64 位模式将通用寄存器和 SIMD 扩展寄存器的数量从 8 升到了 16。并且通用寄存器扩展到 64 位。该模式还引入了一个新的操作码前缀（rex）以访问寄存器的扩展位。有关详细说明，请参见第 3.2.1 节。

  操作系统以代码段为基础启用 64 位模式。其默认地址大小为 64 位，其默认操作数大小为 32 位。可以使用 REX 操作码前缀和操作数大小覆盖前缀在逐条指令的基础上覆盖默认操作数大小。

  REX 前缀允许在 64 位模式下指定 64 位操作数。通过此机制，许多现有指令允许使用 64位寄存器和 64 位地址。

## 3.4 BASIC PROGRAM EXECUTION REGISTERS

### 3.4.2 段寄存器

@翻译人：墨

段寄存器控制（代码段寄存器，数据段寄存器，堆栈段寄存器，扩展段寄存器，标志段寄存器，全局段寄存器）16 位的段选择子。段选择子是一种特殊的指针，用来标识内存中的段。为了访问内存中特定的段，该段的段选择子必须存在于适当的段寄存器中。

在编写应用代码的时候，程序员通常用汇编指令和标识符创建段选择子。汇编器和其他工具通过这些汇编指令和标识符创建实际的段选择子的值。如果编写系统代码，程序员需要直接创建段选择子。可以参考 Intel® 64 and IA-32 软件架构开发手册卷三的第三章：保护模式下的内存管理。

如何使用段寄存器取决于操作系统或执行器使用的内存管理模型。在平坦模型（未进行分段）下，段寄存器加载指向重叠段的段选择子，每个段都从线性地址空间的0地址处开始（见图 3-6 ）。这些重叠
的段构成了程序的线性地址空间。通常定义两个重叠段：一个用于代码，另一个用于数据和堆栈。 CS 段寄存器指向代码段，其他所有段寄存器指向数据和堆栈段。
                                                                    图3-6

使用分段内存模型时，每个段寄存器通常加载不同的段选择子，以便每个段选择子指向线性地址空间内的不同段（见图 3-7 ）。因此在任何时候，程序最多可以访问线性地址空间中的六个段。要访问一个没有被任何段寄存器指向的段，程序必须先加载一个段选择子用来访问段寄存器。
                                                                    图3-7

每个段寄存器都与以下三种存储类型相关联：代码，数据或堆栈。比如，CS寄存器包含代码段的段选择子，存储正在执行的指令。处理器从代码段中获取指令，使用的逻辑地址由CS寄存器中的段选择子和
 EIP 寄存器的内容组成。 EIP 寄存器包含了代码段中下一条被执行的指令的偏移量。 CS 寄存器不能由应用程序显式加载。而是通过改变程序控制的指令或内部处理器操作隐式加载（比如过程调用，中断处理或任务切换）。

DS , ES , FS 和 GS 寄存器指向四个数据段。四个数据段可以安全有效的的访问不同类型的数据结构。比如创建四个独立的数据段：第一个用于当前模块的数据结构，第二个用于从高级模块导出的数据，第三个用于动态创建的结构体，第四个用于和其他程序的共享数据。为了访问额外的数据段，应用程序必须根据需要将这些段的段选择子加载到 DS , ES , FS 和 GS 寄存器中。

SS 寄存器包含了堆栈段的段选择子，当前正在执行的程序，任务或处理程序的过程堆栈都存储在这里。所有的堆栈操作都使用 SS 寄存器来查找堆栈。不像 CS 寄存器， SS 寄存器可以被显式加载，这允许应用程序建立多个堆栈并在它们之间切换。

参考 3.3 ，"内存组织"，了解段寄存器如何在实模式下使用。

CS , DS , SS 和 ES 这四个段寄存器与 Intel 8086 and Intel 286 处理器中的段寄存器相同，而 FS 和 GS 寄存器通过 Intel386™ 系列处理器引入到 IA-32 结构中的。

#### 3.4.2.1 64位模式下的段寄存器

@翻译人：墨

在 64 位模式下：CS , DA , ES , SS 每个段基址被视为 0 ，而不管相关段描述符基址的值。这为代码，数据和堆栈创建了一个平坦地址空间。FS 和 GS 是例外。这两个段寄存器在计算线性地址时都可以作为附加基址寄存器（在本地数据和某些操作系统的数据结构中寻址）。

即使分段通常被禁用，段寄存器加载也可能会导致处理器执行段访问辅助。这些活动进行期间，处理器仍然可以对加载值进行大多数传统检查（即使这些检查不适用于64位模式）。需要这些检查是因为
在 64 位模式下加载的段寄存器可能会被兼容模式下运行的应用程序所使用。

在 64 位模式下禁用 CS , DA , ES , SS , FS 和 GS 的限制检查。

# 第四章 Data Types

## 4.1 FUNDAMENTAL DATA TYPES

### 4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords

@翻译人：符宇舟Alex

## 4.2 NUMERIC DATA TYPES

### 4.2.1 Integers

#### 4.2.1.1 Unsigned Integers

@翻译人：符宇舟Alex

#### 4.2.1.2 Signed Integers

@翻译人：符宇舟Alex

## 4.4 BIT FIELD DATA TYPE
[@翻译人：Hola39e](https://github.com/Hola39e)

位域数据类型（见图4-6）是一个连续的比特序列。它可以从内存中任何字节的任何位开始，最多可以包含32位。

                                Figure 4-6 here
## 4.5 STRING DATA TYPES
[@翻译人：Hola39e](https://github.com/Hola39e)

字符串数据类型是比特、字节、字或双字的连续序列。一个比特串可以从任何字节的任何比特位置开始，并且可以包含最多$2^{32}-1$个比特。一个字节串可以包含字节、字或双字，并且长度范围可以包含从0到$2^{32}-1$个字节（4GB）。

## 4.6 PACKED SIMD DATA TYPES
[@翻译人：Hola39e](https://github.com/Hola39e)

Intel64和IA-32架构定义与操作一组64位和128位包装（Packed）数据类型，中文又称数据向量，用于单指令多数据流（SIMD）操作。这些打包数据类型的由基本的数据类型（打包对齐的字节、字、双字和四字组成），以及用于进行矢量运算（Packed）指令操作的整数，浮点数基本类型的数值说明。
### 4.6.1 64-Bit SIMD Packed Data Types
[@翻译人：Hola39e](https://github.com/Hola39e)

64位包装（Packed）SIMD数据结构是在Intel MXX指令集中加入到IA-32中去的。它们在MXX寄存器中被操作。基本的64位包装数据类型是打包对齐起来的字节、字以及双字（见图4-7）。当执行SIMD操作时，这些数据结构会被解释成
进行矢量运算（Packed）指令操作的字节、字、双字长度的整数值。

                                Figure 4-7 here

### 4.6.2 128-Bit Packed SIMD Data Types
[@翻译人：Hola39e](https://github.com/Hola39e)

128位包装（Packed）SIMD数据结构是在SSE扩展指令集中被引入到IA-32中去的，在SSE2，SSE3，SSSE3扩展指令集中被使用。它们主要在128位的XMM寄存器和内存中进行操作，基本的128位包装数据类型是打包对齐起来的字节、字、双字、四字组成的（见图4-8）。当对在XMM寄存器中保存的包装（Packed）数据类型执行SIMD操作时，这些数据类型会被解释进行矢量运算（Packed）指令操作或标量运算（Scalar）指令操作的单精度浮点数或双精度浮点数，或者进行矢量运算（Packed）的长度为字节、字、双字、四字的整数值。

                                Figure 4-8 here
# 第五章 Instruction Set Summary

# 第六章 Procedure Calls, Interrupts, and Exceptions

## 6.3 CALLING PROCEDURES USING CALL AND RET

### 6.3.1 Near CALL and RET Operation

@翻译人：si

### 6.3.2 Far CALL and RET Operation

@翻译人：si

## 6.4 INTERRUPTS AND EXCEPTIONS

### 6.4.1 Call and Return Operation for Interrupt or Exception Handling Procedures

@翻译人：si


# 第七章 Programming With General-Purpose Instructions

# 第八章 ~ 第十八章

二期再译

# 第十九章 Input/Output

# 第二十章 Processor Identification and Feature Determination

# 附录 A ~ 附录 D

二期再译
